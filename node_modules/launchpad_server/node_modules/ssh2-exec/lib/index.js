// Generated by CoffeeScript 1.7.1
var EventEmitter, exec, local, remote, stream;

EventEmitter = require('events').EventEmitter;

stream = require('stream');

exec = require('child_process').exec;

module.exports = function() {
  var callback, options;
  if (arguments.length === 1) {
    options = arguments[0];
  } else if (arguments.length === 2) {
    if (typeof arguments[1] === 'function') {
      options = arguments[0];
      callback = arguments[1];
    } else {
      options = {};
      options.ssh = arguments[0];
      options.cmd = arguments[1];
    }
  } else if (arguments.length === 3) {
    if (typeof arguments[2] === 'function') {
      callback = arguments[2];
      options = {};
    } else {
      options = arguments[2];
    }
    options.ssh = arguments[0];
    options.cmd = arguments[1];
  } else if (arguments.length === 4) {
    options = arguments[2];
    options.ssh = arguments[0];
    options.cmd = arguments[1];
    callback = arguments[3];
  } else {
    throw new Error('Invalid arguments');
  }
  if (options.ssh) {
    return remote(options, callback);
  } else {
    return local(options, callback);
  }
};

remote = module.exports.remote = function(options, callback) {
  var child, cmdOptions, exit, stderr, stdout;
  child = new EventEmitter;
  child.stdout = new stream.Readable;
  child.stdout._read = function(_size) {};
  child.stderr = new stream.Readable;
  child.stderr._read = function() {};
  child.kill = function(signal) {
    if (child.proc) {
      return child.proc.end();
    }
  };
  if (options.ssh._host != null) {
    stdout = stderr = '';
    exit = false;
    if (options.cwd) {
      options.cmd = "cd " + options.cwd + "; " + options.cmd;
    }
    cmdOptions = {};
    if (options.env) {
      cmdOptions.env = options.env;
    }
    if (options.pty) {
      cmdOptions.pty = options.pty;
    }
    options.ssh.exec(options.cmd, cmdOptions, function(err, proc) {
      if (err && callback) {
        return callback(err);
      }
      child.proc = proc;
      proc.on('data', function(data, extended) {
        if (exit) {
          return;
        }
        if (extended === 'stderr') {
          child.stderr.push(data);
          if (callback) {
            return stderr += data;
          }
        } else {
          child.stdout.push(data);
          if (callback) {
            return stdout += data;
          }
        }
      });
      return proc.on('exit', function(code, signal) {
        return process.nextTick(function() {
          if (code !== 0) {
            if (stderr.trim().length) {
              err = stderr.trim().split('\n');
              err = err[err.length - 1];
            } else {
              err = 'Child process exited abnormally';
            }
            err = new Error(err);
            err.code = code;
            err.signal = signal;
          }
          exit = true;
          child.stdout.push(null);
          child.stderr.push(null);
          child.emit('exit', code, signal);
          if (options.end) {
            connection.end();
            connection.on('error', function() {
              return callback(err);
            });
            return connection.on('close', function() {
              if (callback) {
                return callback(err, stdout, stderr);
              }
            });
          } else {
            if (callback) {
              return callback(err, stdout, stderr);
            }
          }
        });
      });
    });
  }
  return child;
};

local = module.exports.local = function(options, callback) {
  var child, cmdOptions, stderr, stdout;
  cmdOptions = {};
  cmdOptions.env = options.env || process.env;
  cmdOptions.cwd = options.cwd || null;
  if (options.uid) {
    cmdOptions.uid = options.uid;
  }
  if (options.gid) {
    cmdOptions.gid = options.gid;
  }
  stdout = new stream.Readable;
  stderr = new stream.Readable;
  child = exec(options.cmd, cmdOptions, callback);
  child.stdout = stdout.wrap(child.stdout);
  child.stderr = stderr.wrap(child.stderr);
  return child;
};
